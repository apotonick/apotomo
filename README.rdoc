= Apotomo

<em>Web Components for Rails.</em>

{<img src="https://secure.travis-ci.org/apotonick/apotomo.png" />}[http://travis-ci.org/apotonick/apotomo]

== Overview

Do you need an <b>interactive user interface</b> for your Rails application? A cool Rich Client Application with dashboards, portlets and AJAX, Drag&Drop and jQuery?

Is your controller gettin' fat? And your partial-helper-AJAX pile is getting out of control?

Do you want a framework to make the implementation easier? <b>You want Apotomo.</b> 

== Apotomo

Apotomo is based on {Cells}[http://github.com/apotonick/cells], the popular View Components framework for Rails.

It gives you widgets and encapsulation, bubbling events, AJAX page updates, rock-solid testing and more. Check out http://apotomo.de for a bunch of tutorials and a nice web 2.0 logo.

== Installation

Easy as hell.

=== Rails 3

  gem install apotomo

=== Rails 2.3

  gem install apotomo -v 0.1.4

Don't forget to load the gem in your app, either in your +Gemfile+ or +environment.rb+.

== Example!

A _shitty_ example is worse than a _shitty_ framework, so let's choose wisely...

Say you had a blog application. The page showing the post should have a comments block, with a list of comments and a form to post a new comment. Submitting should validate and send back the updated comments list, via AJAX.

Let's wrap that comments block in a widget.

== Generate

  $ rails g apotomo:widget comments show -e haml
    invoke  haml
    create  app/widgets/comments/views/show.html.haml
    invoke  rspec
    create  spec/widgets/comments/comments_widget_spec.rb
    create  app/widgets/comments/comments_widget.rb
    create  app/assets/stylesheets/widgets/comments_widget.css
    create  app/assets/javascripts/widgets/comments_widget.coffee

Go and generate a widget TopBar stub.

  $ rails g apotomo:widget TopBar show -e haml
    invoke  haml
    create  app/widgets/top_bar/views/show.html.haml
    invoke  rspec
    create  spec/widgets/top_bar/top_bar_widget_spec.rb
    create  app/widgets/top_bar/top_bar_widget.rb
    create  app/assets/stylesheets/widgets/top_bar_widget.css
    create  app/assets/javascripts/widgets/top_bar_widget.coffee

And a Form widget within the TopBar namespace

  $ rails g apotomo:widget TopBar::Form show -e haml
    invoke  haml
    create  app/widgets/top_bar/form/views/show.html.haml
    invoke  rspec
    create  spec/widgets/top_bar/form/form_widget_spec.rb
    create  app/widgets/top_bar/form/form_widget.rb
    create  app/assets/javascripts/widgets/top_bar/form_widget.coffee
    create  app/assets/stylesheets/widgets/top_bar/form_widget.css

== Plug it in

You now tell your controller about the new widget.

  class PostsController < ApplicationController
    include Apotomo::Rails::ControllerMethods
    
    has_widgets do |root|
      root << widget(:comments, :post => @post)
    end

This creates a widget instance called <tt>comments_widget</tt> from the class CommentsWidget.  We pass the current post into the widget - the block is executed in controller instance context, that's were <tt>@post</tt> comes from. Handy, isn't it?

== Render the widget

Rendering usually happens in your controller view, <tt>views/posts/show.html.haml</tt>, for instance.

  %h1 @post.title
  
  %p
    @post.body
  
  %p
    = render_widget :comments

== Write the widget

A widget is like a cell which is like a mini-controller.

  class CommentsWidget < Apotomo::Widget
    responds_to_event :post
    
    def show(args)
      @comments = args[:post].comments # the parameter from outside.
      render
    end

Having +show+ as the default state when rendering, this method collects comments to show and renders its view.

And look at line 2 - if encountering a <tt>:post</tt> event we invoke +#post+, which is simply another state. How cool is that? 

    def post(evt)
      @comment = Comment.new(:post_id => evt[:post_id])
      @comment.update_attributes evt[:comment]  # a bit like params[].
      
      update :state => :show
    end
  end


The event is processed with three steps in our widget:

* create the new comment
* re-render the +show+ state
* update itself on the page

Apotomo helps you focusing on your app and takes away the pain of <b>action dispatching</b> and <b>page updating</b>.

== Triggering events

So how and where is the <tt>:post</tt> event triggered?

Take a look at the widget's view <tt>show.html.haml</tt>.
  = widget_div do
    %ul
      - for c in @comments
        %li c.text
    
    - form_for :comment, @comment, :url => url_for_event(:post), :remote => true do |f|
      = f.error_messages
      = f.text_field :text
  
      = submit_tag "Don't be shy, comment!"

That's a lot of familiar view code, almost looks like a _partial_.

As soon as the form is submitted, the form gets serialized and sent using the standard Rails mechanisms. The interesting part here is the endpoint URL returned by #url_for_event as it will trigger an Apotomo event.

== Event processing

Now what happens when the event request is sent? Apotomo - again - does three things for you, it

* <b>accepts the request</b> on a special event route it adds to your app
* <b>triggers the event</b> in your ruby widget tree, which will invoke the +#post+ state in our comment widget
* <b>sends back</b> the page updates your widgets rendered

== JavaScript Agnosticism

In this example, we use jQuery for triggering. We could  also use Prototype, RightJS, YUI, or a self-baked framework, that's up to you.

Also, updating the page is in your hands. Where Apotomo provides handy helpers as +#replace+, you could also <b>emit your own JavaScript</b>.

Look, +replace+ basically generates

  $("comments").replaceWith(<the rendered view>);

If that's not what you want, do

  def post(evt)
    if evt[:comment][:text].explicit?
      render :text => 'alert("Hey, you wanted to submit a pervert comment!");'
    end
  end

Apotomo doesn't depend on _any_ JS framework - you choose!

== jQuery helpers

* element(id)
* update(id, markup)
* replace(id, markup)
* update_id(id, markup)
* replace_id(id, markup)

Extras (jQuery only):

* find_element(id, selector)
* selector_for(var, id, selector)
* call_fun(name, id, hash)

Example usage:

```ruby
top_item = selector_for(:top_item, widget_id, '.item:first')
render js: top_item + append_to(:_top_item, markup)

Will select `.item:first` under the widget container element as a variable `_apo_top_item` and then append the markup to the DOM element(s) pointed to by that variable.
```

Inverse jQuery manipulation API

* append_to(selector, markup)
* prepend_to(selector, markup)
* replace_all(selector, markup)

Normal jQuery manipulation API

* update_text(id, selector, markup)
* append(id, selector, markup)
* prepend(id, selector, markup)
* after(id, selector, markup)
* before(id, selector, markup)
* unwrap(id, selector)
* wrap(id, selector, markup)
* wrap_inner(id, selector, markup)
* wrap_all(id, selector, markup)
* remove(id, selector)
* remove_class(id, selector, *classes)
* add_class(id, selector, *classes)
* toggle_class(id, selector, *classes)
* toggle_class_fun(id, selector, fun)
* empty(id, selector)

jQuery "get" functions

* get_attr(id, selector, name)
* get_prop(id, selector, name)
* get_val(id, selector)
* get_html(id, selector)

The first argument `id` is always optional. It is meant to be used to select the div for the widget. The `selector` then finds one or more elements within the widget to perform the action on.

These functions should be used sparingly, for _Proof of Concept_ only if possible. It is far better to have javascript asset files if possible (== non-intrusive javascript).

A non-intrusive approach could involve the use of the `call_fun` method which takes the `name` of the javascript method to call, the widget `id` and a hash of data.

Example: 

`call_fun :toggle_active, 'TopBar', {item: 'item:first'}`

This will result in the call:

```javascript
Widget.TopBar.toggleActive({'item': 'item:first'});
```

This ensures that all our javascript for a widget is namespace contained nicely.

In your `application.js` manifest file

```
//= require apotomo/Namespace
```

In the `top_bar.coffee` file the following is generated for our convenience

```javascript
Widget.TopBar = Namespace('Apotomo.Widget.TopBar');

Widget.TopBar = {}
```

We can then implement clean non-intrusive, namespaced javascript functionality as follows:

```javascript
Widget.TopBar = Namespace('Apotomo.Widget.TopBar');

Widget.TopBar = {
  update: function(item) {
    'updated:' + item }
  },
  
  toggleActive: function(widget_id, options) {
    item = options['item'];
    // do some toggle magic!!!
    $(widget_id).find(item).toggleClass('active');
  }
}
```

Note that you can use fx jQuery [extend](http://api.jquery.com/jQuery.extend/) to extend javascript widget functionality similar to modules (prototypical inheritance). 
There are many other powerful javascript libraries out there (fx Base2, Prototype.js, JS.Class) that can be used to great effect for OOP javascript with inheritance etc. 

```coffeescript
$.extend Widget.Admin.TopBar, Widget.TopBar
```

Here we extended the `Admin.TopBar` with base functionality from `TopBar` :)

== Using Coffeescript

Coffeescript has built in [class structure](http://coffeescript.org/#classes).
and [namespaces](http://spin.atomicobject.com/2011/04/01/namespace-a-coffeescript-nugget/). Also see [namespaced classes](http://stackoverflow.com/questions/8730859/classes-within-coffeescript-namespace)

```coffeescript
namespace "Widget.TopBar", (exports) ->
  # add functions or classes here
  bar: (foo) ->
```

```coffeescript
class MyFirstWidget
  constructor: (options = {}) ->
    @options = options
    @name = options.name
  myFunc: () ->
    console.log 'works'

namespace "Widget.TopBar", (exports) ->
  exports.MyFirstWidget = MyFirstWidget

  toggleActive: (widget_id, options) ->
    item = options.item
    $(widget_id).find(item).toggleClass 'active'
```

```coffeescript
firstWidget = new Widget.TopBar.MyFirstWidget
firstWidget.myFunc
```

=== javascript Widget instance

For an Ajax enabled page, you can create javascript widget instances in the `Widgets` namespace.

```coffeescript
Widgets.firstWidget = new Widget.TopBar.MyFirstWidget name: "cool widget"
``

Then you can update an existing widget instance from your Widget (controller) using `call_widget` as follows:

```ruby
call_widget :firstWidget, :flash_light, action: 'search'
```

Which will result in the statement:

```javascript
Widgets.firstWidget.flashLight('action': 'search');
```

An even better way...

See [namespace.coffee](https://github.com/CodeCatalyst/namespace.coffee) for a good namespacing/package solution for coffee classes, as described in [oop coffee](http://www.gridlinked.info/oop-with-coffeescript-javascript/)

```coffeescript
namespace "samples.coffeescript.oop"
    PetMaker :
        class PetMaker
            constructor : ->
 
            createDog : (name) -> new Dog(name)
            createCat : (name) -> new Cat(name)
            createBird: (name) -> new Bird(name)
 
      # private variable declarations (aliases)
      #
      Dog = samples.coffeescript.oop.pets.Dog
      Cat = samples.coffeescript.oop.pets.Cat
      Bird= samples.coffeescript.oop.pets.Bird
```

== Testing

Apotomo comes with its own test case and assertions to <b>build rock-solid web components</b>.

  class CommentsWidgetTest < Apotomo::TestCase
    has_widgets do |root|
      root << widget(:comments, :post => @pervert_post)
    end
    
    def test_render
      render_widget :comments
      assert_select "li#me"
      
      trigger :post, :comment => {:text => "Sex on the beach"}
      assert_response 'alert("Hey, you wanted to submit a pervert comment!");'
    end
  end

You can render your widgets, spec the markup, trigger events and assert the event responses, so far. If you need more, let us know!

== More features

There's even more, too much for a simple README.

[Statefulness]      Deriving your widget from +StatefulWidget+ gives you free statefulness.
[Composability]     Widgets can range from small standalone components to nested widget trees like complex dashboards.
[Bubbling events]   Events bubble up from their triggering source to root and thus can be observed, providing a way to implement loosely coupled, distributable components.           
[Team-friendly]     Widgets encourage encapsulation and help having different developers working on different components without getting out of bounds.


Give it a try- you will love the power and simplicity of real web components!


== Bugs, Community
Please visit http://apotomo.de, the official project page with <em>lots</em> of examples.

If you have questions, visit us in the IRC channel #cells at irc.freenode.org.

If you wanna be cool, subscribe to our feed[http://feeds.feedburner.com/Apotomo]!


== License
Copyright (c) 2007-2012 Nick Sutterer <apotonick@gmail.com> under the MIT License
